"use strict";(self.webpackChunkgds_bootcamp=self.webpackChunkgds_bootcamp||[]).push([[9188],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=o.createContext({}),s=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=s(e.components);return o.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),h=s(n),u=a,k=h["".concat(c,".").concat(u)]||h[u]||p[u]||r;return n?o.createElement(k,i(i({ref:t},d),{},{components:n})):o.createElement(k,i({ref:t},d))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=h;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var s=2;s<r;s++)i[s]=n[s];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},1491:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var o=n(7462),a=(n(7294),n(3905));const r={},i="2.2 Done When I Say So",l={unversionedId:"frontend/DoneWhenISaySo",id:"frontend/DoneWhenISaySo",title:"2.2 Done When I Say So",description:"\ud83d\udca1 If you haven't completed Exercise 1.1, get up to speed by switching to the frontend/checkpoint-1 branch!",source:"@site/docs/frontend/22-DoneWhenISaySo.md",sourceDirName:"frontend",slug:"/frontend/DoneWhenISaySo",permalink:"/docs/frontend/DoneWhenISaySo",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/frontend/22-DoneWhenISaySo.md",tags:[],version:"current",sidebarPosition:22,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"2.1 Submitting To Do",permalink:"/docs/frontend/SubmitToDo"},next:{title:"2.3 Preventing Mistakes",permalink:"/docs/frontend/PreventingMistakes"}},c={},s=[{value:"Adding a Checkbox",id:"adding-a-checkbox",level:2},{value:"Creating a state for each checkbox",id:"creating-a-state-for-each-checkbox",level:2},{value:"Making use of Done state variable",id:"making-use-of-done-state-variable",level:2},{value:"Persist the checkbox state",id:"persist-the-checkbox-state",level:2},{value:"When to update Backend",id:"when-to-update-backend",level:3},{value:"Time to update Backend",id:"time-to-update-backend",level:3},{value:"Deleting the todo item",id:"deleting-the-todo-item",level:3}],d={toc:s};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"22-done-when-i-say-so"},"2.2 Done When I Say So"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\ud83d\udca1 If you haven't completed Exercise 1.1, get up to speed by switching to the ",(0,a.kt)("inlineCode",{parentName:"p"},"frontend/checkpoint-1")," branch!")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"git checkout frontend/checkpoint-1"))),(0,a.kt)("p",null,"Visual feedback is an important way of communicating with the user."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"As a user, I would want be able to check the items so that I can track the state of each item in the to do list")),(0,a.kt)("p",null,"In this exercise, we will add a check box for each item to the Todo application."),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"adding-a-checkbox"},"Adding a Checkbox"),(0,a.kt)("p",null,"Lets start by adding a input checkbox. We can use the form checkbox from the SGDS component library."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"<FormCheck />\n")),(0,a.kt)("p",null,"This checkbox should be placed in line with the item description display for easier reference"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},'return (\n  <>\n    <tr>\n      <td>{/* insert checkbox here  */}</td>\n      <td width={"100%"}>{props.description}</td>\n      <td>\n        <img\n          alt="delete-icon"\n          src={crossIcon}\n          onClick={deleteTodoItem}\n          className="delete-icon"\n        />\n      </td>\n    </tr>\n  </>\n);\n')),(0,a.kt)("p",null,"Here we are using default html input tag with the checkbox type"),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"creating-a-state-for-each-checkbox"},"Creating a state for each checkbox"),(0,a.kt)("p",null,"With the checkbox create we will want to keep track of the state when checkbox is click to done.\nLet's use the useState hook as before."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"const [done, setDone] = useState(props.done);\n")),(0,a.kt)("p",null,"Here we are initializing a state for each item to the ",(0,a.kt)("inlineCode",{parentName:"p"},"done")," variable and we are using the ",(0,a.kt)("inlineCode",{parentName:"p"},"props.done")," from ",(0,a.kt)("inlineCode",{parentName:"p"},"TodoItemProps")," which is a type defined for each todo item."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"setDone")," provides us a setter method to update the state when we want to."),(0,a.kt)("h2",{id:"making-use-of-done-state-variable"},"Making use of Done state variable"),(0,a.kt)("p",null,"Now let's make use of the state variable created to keep track of each checkbox being marked/unmarked."),(0,a.kt)("p",null,"First we will need to hook a call to the ",(0,a.kt)("inlineCode",{parentName:"p"},"setDone")," method when checkbox is being clicked/changed."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"onChange={(event) => setDone(event.currentTarget.checked)}\n")),(0,a.kt)("p",null,"Add ",(0,a.kt)("inlineCode",{parentName:"p"},"onChange")," code above to the checkbox input that you have created. This will call the ",(0,a.kt)("inlineCode",{parentName:"p"},"setDone")," method to update the ",(0,a.kt)("inlineCode",{parentName:"p"},"done")," state every time the checkbox is clicked.\nNow we will need to link the ",(0,a.kt)("inlineCode",{parentName:"p"},"done")," state variable to the checkbox so that the state is reflected correctly as it is currently not being used."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"checked = { done };\n")),(0,a.kt)("p",null,"Add the above to the checkbox input you created. This would ensure that the checkbox input is reflecting using the ",(0,a.kt)("inlineCode",{parentName:"p"},"done")," state variable."),(0,a.kt)("p",null,"You should be seeing a similar block of code as below"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"<td>\n  <FormCheck /* Insert code here */ />\n</td>\n")),(0,a.kt)("h2",{id:"persist-the-checkbox-state"},"Persist the checkbox state"),(0,a.kt)("p",null,"Now try refreshing the page and you will realise that although you can check the box but upon refresh the state is not persistent. So the next thing we have to do is to persist the state through back end means."),(0,a.kt)("h3",{id:"when-to-update-backend"},"When to update Backend"),(0,a.kt)("p",null,"First we will need to track changes made for the checkbox for each item so that we know when to send the update to the back end and an easy way to do it in react is using the ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," hook with dependencies ",(0,a.kt)("inlineCode",{parentName:"p"},"done")," state variable."),(0,a.kt)("p",null,"To have visibility on the behaviour lets add ",(0,a.kt)("inlineCode",{parentName:"p"},"console.log")," to display item description and done state variable."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"useEffect(() => {\n  /* Insert code here */\n}, [props.description, done]);\n")),(0,a.kt)("p",null,"With ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," when there are changes(updates) detected on any of the dependencies ",(0,a.kt)("inlineCode",{parentName:"p"},"[props.description, done]"),". This method will be triggered."),(0,a.kt)("p",null,"To view the method being triggered, inspect and view console, you will see that every time the checkbox is clicked the console will be logged with the message. You will also be able to observed that each checkbox has its own state being stored."),(0,a.kt)("h3",{id:"time-to-update-backend"},"Time to update Backend"),(0,a.kt)("p",null,"We have created the trigger point using ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," to call and update the back end. Now we will just need to link the backend api call with ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"useEffect(() => {\n  /* Console log code */\n  /* Insert code here */\n}, [props.description, done /* Insert code here */]);\n")),(0,a.kt)("p",null,"By adding ",(0,a.kt)("inlineCode",{parentName:"p"},"updateTodoItem"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," will always call the ",(0,a.kt)("inlineCode",{parentName:"p"},"updateTodoItem")," method every time it detects a change in the ",(0,a.kt)("inlineCode",{parentName:"p"},"done")," state variable."),(0,a.kt)("p",null,"Now to update ",(0,a.kt)("inlineCode",{parentName:"p"},"updateTodoItem")," to use the done state variable"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"const updateTodoItem = useCallback(async () => {\n  await axios.put(`${CONFIG.API_ENDPOINT}/todos/${props.id}`, {\n    id: props.id,\n    description: props.description,\n    done: false /* Update false */,\n  });\n}, [props.description, props.id /* Insert code here */]);\n")),(0,a.kt)("p",null,"Congratulations, now your state is persisted and refreshing will no longer pose a problem."),(0,a.kt)("h3",{id:"deleting-the-todo-item"},"Deleting the todo item"),(0,a.kt)("p",null,"Could you update the cross icon to delete the to-do item when clicked?\nUse the delete endpoint from the backend to achieve this task. Remember to reload the to-do list after deleting!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"const deleteTodoItem = useCallback(async () => {\n  // delete item here\n  // refresh to-do list here\n}, [props.id, props.refreshToDos]);\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},'<>\n  <tr>\n    <td>\n      <FormCheck\n        onChange={(event) => setDone(event.currentTarget.checked)}\n        checked={done}\n      />\n    </td>\n    <td width={"100%"}>{props.description}</td>\n    <td>\n      <img\n        alt="delete-icon"\n        src={crossIcon}\n        onClick={/* insert delete function here */}\n        className="delete-icon"\n      />\n    </td>\n  </tr>\n</>\n')))}p.isMDXComponent=!0}}]);